Yes, the image provided shows the full problem statement and all necessary details to solve the problem.

### Problem Analysis

**Problem Statement:**
Given two integer arrays, `p` and `s`, both of length `n`, we need to determine if there exists an array `a` of length `n` such that `p` is the prefix GCD array of `a` and `s` is the suffix GCD array of `a`.

The definitions are:
- `p_i = gcd(a_1, a_2, ..., a_i)`
- `s_i = gcd(a_i, a_{i+1}, ..., a_n)`

where `gcd` denotes the greatest common divisor.

---

### Constraints, Input/Output, and Examples

**Constraints:**
*   `1 <= t <= 10^4` (number of test cases)
*   `1 <= n <= 10^5` (length of the arrays)
*   `1 <= p_i, s_i <= 10^9` (values in the arrays)
*   The sum of `n` over all test cases does not exceed `10^5`.

**Input Format:**
*   The first line contains an integer `t`.
*   Each test case consists of three lines:
    1.  An integer `n`.
    2.  `n` space-separated integers for the array `p`.
    3.  `n` space-separated integers for the array `s`.

**Output Format:**
*   For each test case, output "Yes" if a valid array `a` exists, and "No" otherwise.

**Examples from the screenshot:**
1.  **Input:**
    ```
    6
    72 24 3 3 3 3
    3 3 3 6 12 144
    ```
    **Output:** `YES`

2.  **Input:**
    ```
    3
    1 2 3
    4 5 6
    ```
    **Output:** `NO`

3.  **Input:**
    ```
    5
    125 125 125 25 25
    25 25 25 25 75
    ```
    **Output:** `NO`

---

### Solution Approach

Let's deduce the necessary conditions for such an array `a` to exist. We will show that these conditions are also sufficient.

**1. Monotonicity of GCDs:**
*   From the definition `p_i = gcd(a_1, ..., a_i) = gcd(p_{i-1}, a_i)` for `i > 1`. A property of GCD is that `gcd(x, y)` divides both `x` and `y`. Therefore, `p_i` must divide `p_{i-1}` for all `i = 2, ..., n`.
*   Similarly, `s_i = gcd(a_i, ..., a_n) = gcd(a_i, s_{i+1})` for `i < n`. This implies `s_i` must divide `s_{i+1}` for all `i = 1, ..., n-1`.

**2. Global GCD:**
*   The GCD of the entire array `a` can be computed in two ways:
    *   As the last element of the prefix GCD array: `p_n = gcd(a_1, ..., a_n)`.
    *   As the first element of the suffix GCD array: `s_1 = gcd(a_1, ..., a_n)`.
*   Therefore, a necessary condition is `p_n == s_1`.

**3. Local Constructibility of `a_i`:**
*   For each element `a_i`, it must satisfy the relations:
    *   `p_i = gcd(p_{i-1}, a_i)` (for `i > 1`) and `p_1 = a_1`.
    *   `s_i = gcd(a_i, s_{i+1})` (for `i < n`) and `s_n = a_n`.
*   From these relations, `p_i` must divide `a_i` and `s_i` must divide `a_i`. This means `a_i` must be a multiple of their least common multiple, `lcm(p_i, s_i)`.
*   Let's see if we can construct a valid `a`.
    *   For `i=1`, we must have `a_1 = p_1`. The suffix condition becomes `s_1 = gcd(a_1, s_2) = gcd(p_1, s_2)`.
    *   For `i=n`, we must have `a_n = s_n`. The prefix condition becomes `p_n = gcd(p_{n-1}, a_n) = gcd(p_{n-1}, s_n)`.
    *   For `1 < i < n`, we need to find an `a_i` that is a multiple of `lcm(p_i, s_i)` and satisfies `p_i = gcd(p_{i-1}, a_i)` and `s_i = gcd(a_i, s_{i+1})`.
*   If such an `a_i` exists, then the simplest candidate, `a_i = lcm(p_i, s_i)`, must also satisfy weaker conditions. If `gcd(p_{i-1}, lcm(p_i, s_i))` is some value `G` which is a multiple of `p_i` but `G != p_i`, then for any `a_i` which is a multiple of `lcm(p_i, s_i)`, `gcd(p_{i-1}, a_i)` will be a multiple of `G`, and thus cannot be `p_i`.
*   Therefore, if a solution exists at all, it must be possible to construct one. The choice `a_i = lcm(p_i, s_i)` for `1 < i < n`, `a_1 = p_1`, and `a_n = s_n` must work. This leads to the following checks for `1 < i < n`:
    *   `p_i == gcd(p_{i-1}, lcm(p_i, s_i))`
    *   `s_i == gcd(lcm(p_i, s_i), s_{i+1})`

**Summary of Conditions to Check (using 0-based indexing):**
1.  `p[i-1] % p[i] == 0` for `i = 1, ..., n-1`.
2.  `s[i+1] % s[i] == 0` for `i = 0, ..., n-2`.
3.  `p[n-1] == s[0]`.
4.  For `n > 1`:
    *   `s[0] == gcd(p[0], s[1])`.
    *   `p[n-1] == gcd(p[n-2], s[n-1])`.
5.  For `n > 2`, for `i = 1, ..., n-2`:
    *   Let `m_i = lcm(p[i], s[i])`.
    *   `p[i] == gcd(p[i-1], m_i)` must hold.
    *   `s[i] == gcd(m_i, s[i+1])` must hold.

If all these conditions are met, a valid array `a` exists. Otherwise, it does not.

---

### C++ Solution

```cpp
#include <iostream>
#include <vector>
#include <numeric>

// Function to calculate Least Common Multiple (LCM) safely to avoid overflow.
long long lcm(long long a, long long b) {
    if (a == 0 || b == 0) return 0;
    if (a == 1) return b;
    if (b == 1) return a;
    long long common = std::gcd(a, b);
    // (a / common) * b is safer than (a * b) / common
    return (a / common) * b;
}

void solve() {
    int n;
    std::cin >> n;
    std::vector<long long> p(n), s(n);
    for (int i = 0; i < n; ++i) std::cin >> p[i];
    for (int i = 0; i < n; ++i) std::cin >> s[i];

    if (n == 1) {
        // For n=1, a_1 = p_1 and a_1 = s_1, so p_1 must equal s_1.
        if (p[0] == s[0]) {
            std::cout << "Yes\n";
        } else {
            std::cout << "No\n";
        }
        return;
    }

    // Check 1: Monotonicity of p (p_i must divide p_{i-1})
    for (int i = 1; i < n; ++i) {
        if (p[i - 1] % p[i] != 0) {
            std::cout << "No\n";
            return;
        }
    }

    // Check 2: Monotonicity of s (s_i must divide s_{i+1})
    for (int i = 0; i < n - 1; ++i) {
        if (s[i + 1] % s[i] != 0) {
            std::cout << "No\n";
            return;
        }
    }

    // Check 3: Global GCD (p_n must equal s_1)
    if (p[n - 1] != s[0]) {
        std::cout << "No\n";
        return;
    }

    // Check 4: Local constructibility at boundaries
    // For a_1 (0-indexed a_0)
    if (s[0] != std::gcd(p[0], s[1])) {
        std::cout << "No\n";
        return;
    }
    // For a_n (0-indexed a_{n-1})
    if (p[n - 1] != std::gcd(p[n - 2], s[n - 1])) {
        std::cout << "No\n";
        return;
    }
    
    // Check 5: Local constructibility for intermediate elements
    for (int i = 1; i < n - 1; ++i) {
        long long m_i = lcm(p[i], s[i]);
        if (p[i] != std::gcd(p[i - 1], m_i) || s[i] != std::gcd(m_i, s[i + 1])) {
            std::cout << "No\n";
            return;
        }
    }

    std::cout << "Yes\n";
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```