{
  "sdk_http_response": "headers={'content-type': 'application/json; charset=UTF-8', 'vary': 'Origin, X-Origin, Referer', 'content-encoding': 'gzip', 'date': 'Sun, 28 Sep 2025 09:47:14 GMT', 'server': 'scaffolding on HTTPServer2', 'x-xss-protection': '0', 'x-frame-options': 'SAMEORIGIN', 'x-content-type-options': 'nosniff', 'server-timing': 'gfet4t7; dur=164911', 'alt-svc': 'h3=\":443\"; ma=2592000,h3-29=\":443\"; ma=2592000', 'transfer-encoding': 'chunked'} body=None",
  "candidates": [
    "content=Content(\n  parts=[\n    Part(\n      text=\"\"\"Yes, the image shows the full problem statement and all necessary details.\n\n### Problem Breakdown\n\n1.  **Objective:** Given an even number `n` of points on a 2D plane, partition them into `n/2` disjoint pairs `(a_i, b_i)` to maximize the total sum of Manhattan distances between the points in each pair. The sum to maximize is `\u03a3 (|x_{a_i} - x_{b_i}| + |y_{a_i} - y_{b_i}|)`.\n\n2.  **Constraints:**\n    *   Number of test cases `t`: `1 \u2264 t \u2264 10^4`.\n    *   Number of points `n`: `2 \u2264 n \u2264 2 * 10^5`, `n` is even.\n    *   Coordinates `x_i`, `y_i`: `-10^6 \u2264 x_i, y_i \u2264 10^6`.\n    *   The sum of `n` over all test cases does not exceed `2 * 10^5`.\n\n3.  **Input Format:**\n    *   The first line contains `t`, the number of test cases.\n    *   Each test case starts with a line containing an even integer `n`.\n    *   The following `n` lines each contain two integers, `x_i` and `y_i`, representing the coordinates of the `i`-th point (1-indexed).\n\n4.  **Output Format:**\n    *   For each test case, output `n/2` lines.\n    *   Each line must contain two space-separated integers, `a_i` and `b_i`, which are the 1-based indices of the points forming a pair.\n    *   If multiple solutions exist, any valid pairing that yields the maximum sum is acceptable.\n\n5.  **Example:**\n    *   **Input:**\n        ```\n        2\n        4\n        1 1\n        3 0\n        4 2\n        3 4\n        10\n        -1 -1\n        -1 2\n        -2 -2\n        -2 0\n        0 2\n        2 -3\n        -4 -4\n        -4 -2\n        0 1\n        -4 2\n        ```\n    *   **Note:** The example output is not provided in the screenshot, but a valid output will be generated by the solution.\n\n### Solution Approach\n\nThe objective is to maximize the sum `S = \u03a3_{i=1}^{n/2} (|x_{a_i} - x_{b_i}| + |y_{a_i} - y_{b_i}|)`.\n\nWe can rearrange the sum as:\n`S = (\u03a3_{i=1}^{n/2} |x_{a_i} - x_{b_i}|) + (\u03a3_{i=1}^{n/2} |y_{a_i} - y_{b_i}|)`\n\nThis shows that the total sum is a sum of two components: the sum of horizontal distances and the sum of vertical distances. To maximize the total sum `S`, we want to make both components large.\n\nLet's focus on maximizing the first component, `S_x = \u03a3 |x_{a_i} - x_{b_i}|`. This subproblem is independent of the `y` coordinates. To maximize the sum of absolute differences for a set of `n` numbers, the optimal strategy is to pair the smallest numbers with the largest numbers. Specifically, if we sort the `x` coordinates as `x'_1 \u2264 x'_2 \u2264 ... \u2264 x'_n`, the maximum sum is achieved by pairing the `n/2` smallest values with the `n/2` largest values. The total sum becomes `(x'_n + ... + x'_{n/2+1}) - (x'_1 + ... + x'_{n/2})`. This is achieved, for example, by pairing the `i`-th smallest `x` with the `i`-th largest `x` (i.e., pairing `x'_i` with `x'_{n-i+1}`).\n\nThe challenge is that a single pairing must be chosen for both the `x` and `y` components. A pairing that is optimal for the `x` coordinates might not be optimal for the `y` coordinates.\n\nHowever, a strong greedy strategy is to choose a pairing that is fully optimal for one of the components. Let's try to create a pairing that maximizes `S_x` and see what happens.\n\n**The Greedy Strategy:**\n1.  Sort all the points based on their `x`-coordinate.\n2.  Partition the sorted points into two halves: the first `n/2` points (with the smallest `x` values) and the second `n/2` points (with the largest `x` values).\n3.  Pair the `i`-th point from the first half with the `i`-th point from the second half. That is, pair the point at index `i` with the point at index `i + n/2` in the sorted list (using 0-based indexing).\n\nThis pairing strategy guarantees that `S_x` is maximized. While it might not maximize `S_y`, it turns out that this approach is sufficient to produce an overall optimal solution. The intuition is that any attempt to improve `S_y` by altering this pairing would lead to a larger loss in `S_x`, resulting in a smaller total sum `S`.\n\n**Algorithm:**\n1.  Read the input points, storing each point's `x`, `y` coordinates and its original 1-based index.\n2.  Create a vector of structures/tuples to hold this information for all `n` points.\n3.  Sort this vector of points primarily based on the `x`-coordinate.\n4.  Iterate from `i = 0` to `n/2 - 1`. In each step, output the original indices of the point at `i` and the point at `i + n/2` from the sorted vector.\n\nThis algorithm has a time complexity of `O(N log N)` due to sorting, which is efficient enough for the given constraints.\n\n### C++ Solution\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n// Structure to store point data including its original index\nstruct Point {\n    long long x, y;\n    int id;\n};\n\n// Comparison function for sorting points based on x-coordinate\nbool comparePoints(const Point& a, const Point& b) {\n    if (a.x != b.x) {\n        return a.x < b.x;\n    }\n    // Tie-breaking by y-coordinate, although not strictly necessary for this problem's logic\n    return a.y < b.y;\n}\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    std::vector<Point> points(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> points[i].x >> points[i].y;\n        points[i].id = i + 1;\n    }\n\n    // Sort points based on their x-coordinate\n    std::sort(points.begin(), points.end(), comparePoints);\n\n    // Pair the i-th point from the first half with the i-th point from the second half\n    for (int i = 0; i < n / 2; ++i) {\n        std::cout << points[i].id << \" \" << points[i + n / 2].id << \"\\n\";\n    }\n}\n\nint main() {\n    // Fast I/O\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t;\n    std::cin >> t;\n    while (t--) {\n        solve();\n    }\n\n    return 0;\n}\n```\"\"\"\n    ),\n  ],\n  role='model'\n) citation_metadata=None finish_message=None token_count=None finish_reason=<FinishReason.STOP: 'STOP'> url_context_metadata=None avg_logprobs=None grounding_metadata=None index=0 logprobs_result=None safety_ratings=None"
  ],
  "create_time": null,
  "model_version": "gemini-2.5-pro",
  "prompt_feedback": null,
  "response_id": "IgTZaMukKtK10-kPmsuOgAw",
  "usage_metadata": "cache_tokens_details=None cached_content_token_count=None candidates_token_count=1774 candidates_tokens_details=None prompt_token_count=313 prompt_tokens_details=[ModalityTokenCount(\n  modality=<MediaModality.TEXT: 'TEXT'>,\n  token_count=55\n), ModalityTokenCount(\n  modality=<MediaModality.IMAGE: 'IMAGE'>,\n  token_count=258\n)] thoughts_token_count=18685 tool_use_prompt_token_count=None tool_use_prompt_tokens_details=None total_token_count=20772 traffic_type=None",
  "automatic_function_calling_history": [],
  "parsed": null
}