Yes, the image shows the full problem statement and all necessary details.

### Problem Breakdown

1.  **Objective:** Given an even number `n` of points on a 2D plane, partition them into `n/2` disjoint pairs `(a_i, b_i)` to maximize the total sum of Manhattan distances between the points in each pair. The sum to maximize is `Σ (|x_{a_i} - x_{b_i}| + |y_{a_i} - y_{b_i}|)`.

2.  **Constraints:**
    *   Number of test cases `t`: `1 ≤ t ≤ 10^4`.
    *   Number of points `n`: `2 ≤ n ≤ 2 * 10^5`, `n` is even.
    *   Coordinates `x_i`, `y_i`: `-10^6 ≤ x_i, y_i ≤ 10^6`.
    *   The sum of `n` over all test cases does not exceed `2 * 10^5`.

3.  **Input Format:**
    *   The first line contains `t`, the number of test cases.
    *   Each test case starts with a line containing an even integer `n`.
    *   The following `n` lines each contain two integers, `x_i` and `y_i`, representing the coordinates of the `i`-th point (1-indexed).

4.  **Output Format:**
    *   For each test case, output `n/2` lines.
    *   Each line must contain two space-separated integers, `a_i` and `b_i`, which are the 1-based indices of the points forming a pair.
    *   If multiple solutions exist, any valid pairing that yields the maximum sum is acceptable.

5.  **Example:**
    *   **Input:**
        ```
        2
        4
        1 1
        3 0
        4 2
        3 4
        10
        -1 -1
        -1 2
        -2 -2
        -2 0
        0 2
        2 -3
        -4 -4
        -4 -2
        0 1
        -4 2
        ```
    *   **Note:** The example output is not provided in the screenshot, but a valid output will be generated by the solution.

### Solution Approach

The objective is to maximize the sum `S = Σ_{i=1}^{n/2} (|x_{a_i} - x_{b_i}| + |y_{a_i} - y_{b_i}|)`.

We can rearrange the sum as:
`S = (Σ_{i=1}^{n/2} |x_{a_i} - x_{b_i}|) + (Σ_{i=1}^{n/2} |y_{a_i} - y_{b_i}|)`

This shows that the total sum is a sum of two components: the sum of horizontal distances and the sum of vertical distances. To maximize the total sum `S`, we want to make both components large.

Let's focus on maximizing the first component, `S_x = Σ |x_{a_i} - x_{b_i}|`. This subproblem is independent of the `y` coordinates. To maximize the sum of absolute differences for a set of `n` numbers, the optimal strategy is to pair the smallest numbers with the largest numbers. Specifically, if we sort the `x` coordinates as `x'_1 ≤ x'_2 ≤ ... ≤ x'_n`, the maximum sum is achieved by pairing the `n/2` smallest values with the `n/2` largest values. The total sum becomes `(x'_n + ... + x'_{n/2+1}) - (x'_1 + ... + x'_{n/2})`. This is achieved, for example, by pairing the `i`-th smallest `x` with the `i`-th largest `x` (i.e., pairing `x'_i` with `x'_{n-i+1}`).

The challenge is that a single pairing must be chosen for both the `x` and `y` components. A pairing that is optimal for the `x` coordinates might not be optimal for the `y` coordinates.

However, a strong greedy strategy is to choose a pairing that is fully optimal for one of the components. Let's try to create a pairing that maximizes `S_x` and see what happens.

**The Greedy Strategy:**
1.  Sort all the points based on their `x`-coordinate.
2.  Partition the sorted points into two halves: the first `n/2` points (with the smallest `x` values) and the second `n/2` points (with the largest `x` values).
3.  Pair the `i`-th point from the first half with the `i`-th point from the second half. That is, pair the point at index `i` with the point at index `i + n/2` in the sorted list (using 0-based indexing).

This pairing strategy guarantees that `S_x` is maximized. While it might not maximize `S_y`, it turns out that this approach is sufficient to produce an overall optimal solution. The intuition is that any attempt to improve `S_y` by altering this pairing would lead to a larger loss in `S_x`, resulting in a smaller total sum `S`.

**Algorithm:**
1.  Read the input points, storing each point's `x`, `y` coordinates and its original 1-based index.
2.  Create a vector of structures/tuples to hold this information for all `n` points.
3.  Sort this vector of points primarily based on the `x`-coordinate.
4.  Iterate from `i = 0` to `n/2 - 1`. In each step, output the original indices of the point at `i` and the point at `i + n/2` from the sorted vector.

This algorithm has a time complexity of `O(N log N)` due to sorting, which is efficient enough for the given constraints.

### C++ Solution

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

// Structure to store point data including its original index
struct Point {
    long long x, y;
    int id;
};

// Comparison function for sorting points based on x-coordinate
bool comparePoints(const Point& a, const Point& b) {
    if (a.x != b.x) {
        return a.x < b.x;
    }
    // Tie-breaking by y-coordinate, although not strictly necessary for this problem's logic
    return a.y < b.y;
}

void solve() {
    int n;
    std::cin >> n;
    std::vector<Point> points(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> points[i].x >> points[i].y;
        points[i].id = i + 1;
    }

    // Sort points based on their x-coordinate
    std::sort(points.begin(), points.end(), comparePoints);

    // Pair the i-th point from the first half with the i-th point from the second half
    for (int i = 0; i < n / 2; ++i) {
        std::cout << points[i].id << " " << points[i + n / 2].id << "\n";
    }
}

int main() {
    // Fast I/O
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```