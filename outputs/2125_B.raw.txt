{
  "sdk_http_response": "headers={'content-type': 'application/json; charset=UTF-8', 'vary': 'Origin, X-Origin, Referer', 'content-encoding': 'gzip', 'date': 'Sun, 28 Sep 2025 10:31:32 GMT', 'server': 'scaffolding on HTTPServer2', 'x-xss-protection': '0', 'x-frame-options': 'SAMEORIGIN', 'x-content-type-options': 'nosniff', 'server-timing': 'gfet4t7; dur=167316', 'alt-svc': 'h3=\":443\"; ma=2592000,h3-29=\":443\"; ma=2592000', 'transfer-encoding': 'chunked'} body=None",
  "candidates": [
    "content=Content(\n  parts=[\n    Part(\n      text=\"\"\"Yes, the image provided shows the full problem statement and all necessary details for solving the problem \"B. Left and Down\" from Codeforces.\n\n### Problem Analysis\n\n**1. Constraints:**\n*   Number of test cases, `t`: `1 \u2264 t \u2264 10^4`\n*   Initial coordinates, `a`, `b`: `1 \u2264 a, b \u2264 10^18`\n*   Maximum move value, `k`: `1 \u2264 k \u2264 10^18`\n*   The values of `a`, `b`, and `k` require the use of 64-bit integers (e.g., `long long` in C++).\n\n**2. Input Format:**\n*   The first line contains a single integer `t`, the number of test cases.\n*   Each of the next `t` lines describes a test case with three space-separated integers `a`, `b`, and `k`.\n\n**3. Output Format:**\n*   For each test case, output a single integer: the minimum total cost to move the robot from `(a, b)` to `(0, 0)`.\n\n**4. Examples:**\n*   **Input:**\n    ```\n    4\n    3 5 15\n    2 3 1\n    12 18 8\n    9 7 5\n    ```\n*   **Output:**\n    ```\n    1\n    2\n    1\n    2\n    ```\n\n### Solution Approach\n\nThe problem asks for the minimum cost to move a robot from `(a, b)` to `(0, 0)`. A move consists of choosing `dx` and `dy` (where `0 \u2264 dx, dy \u2264 k`) and changing the robot's position from `(x, y)` to `(x - dx, y - dy)`. The cost is the number of *unique* pairs `(dx, dy)` used.\n\nThe total displacement required is `(a, b)`. We need to find the minimum number of unique vectors `V_i = (dx_i, dy_i)` such that `(a, b)` can be expressed as a non-negative integer linear combination of these vectors, i.e., `(a, b) = c_1*V_1 + c_2*V_2 + ... + c_m*V_m`, where `m` (the cost) is minimized.\n\n#### Case 1: Minimum Cost is 1\n\nCan we achieve the goal using only one unique vector `V = (dx, dy)`?\nThis would mean `(a, b) = c * (dx, dy)` for some integer `c \u2265 1`.\nThis implies `a = c * dx` and `b = c * dy`.\nFrom this, `c` must be a common divisor of `a` and `b`. The vector `V` would be `(a/c, b/c)`.\nFor `V` to be a valid move, its components must be less than or equal to `k`. That is, `dx \u2264 k` and `dy \u2264 k`, which means `a/c \u2264 k` and `b/c \u2264 k`.\n\nTo give ourselves the best chance of satisfying these conditions, we should make `a/c` and `b/c` as small as possible. This is achieved by choosing the largest possible common divisor for `c`, which is `g = gcd(a, b)`.\nIf we choose `c = g`, the vector components are `a/g` and `b/g`. If `a/g \u2264 k` and `b/g \u2264 k`, then we can use the vector `V = (a/g, b/g)` exactly `g` times to achieve the total displacement of `(a, b)`. The cost is 1.\n\nIf this condition fails for the largest common divisor `g`, it will also fail for any smaller common divisor `c`, because `a/c` and `b/c` would be even larger.\nTherefore, the cost is 1 if and only if `max(a/gcd(a, b), b/gcd(a, b)) \u2264 k`.\n\n#### Case 2: Minimum Cost is 2\n\nIf the condition for a cost-1 solution is not met, the minimum cost must be greater than 1. Let's see if a solution with cost 2 is always possible.\n\nWe need to find two valid vectors, `V_1 = (dx_1, dy_1)` and `V_2 = (dx_2, dy_2)`, that can be combined to form the total displacement `(a, b)`.\n\nConsider the following construction:\n1.  Achieve the `a` displacement along the x-axis using one type of move.\n2.  Achieve the `b` displacement along the y-axis using another type of move.\n\nLet `V_1 = (gcd(a, k), 0)`. This is a valid move vector because `gcd(a, k) \u2264 k`. Since `gcd(a, k)` divides `a`, we can apply this move `a / gcd(a, k)` times to achieve a total x-displacement of `a` and a y-displacement of 0.\n\nLet `V_2 = (0, gcd(b, k))`. This is also a valid move because `gcd(b, k) \u2264 k`. We can apply this move `b / gcd(b, k)` times to get a y-displacement of `b` and an x-displacement of 0.\n\nBy performing both sets of operations, the total displacement is `(a, b)`. Since `a, b, k \u2265 1`, `V_1` and `V_2` are distinct non-zero vectors. This strategy uses two unique vectors, so the cost is 2.\n\nThis construction always works. Therefore, if a cost-1 solution is not possible, a cost-2 solution always is.\n\n#### Final Algorithm\n1.  Read `a`, `b`, and `k`.\n2.  Calculate `g = gcd(a, b)`.\n3.  Check if `a/g \u2264 k` and `b/g \u2264 k`. This is equivalent to `max(a/g, b/g) \u2264 k`.\n4.  If the condition is true, the minimum cost is 1.\n5.  Otherwise, the minimum cost is 2.\n\n### C++ Solution\n\n```cpp\n#include <iostream>\n#include <numeric>      // For std::gcd\n#include <algorithm>    // For std::max\n\n// Function to solve a single test case\nvoid solve() {\n    long long a, b, k;\n    std::cin >> a >> b >> k;\n\n    // Calculate the greatest common divisor of a and b.\n    long long g = std::gcd(a, b);\n\n    // --- Check for Cost 1 ---\n    // A cost of 1 is possible if we can find a single vector (dx, dy)\n    // and a number of repetitions 'c' such that c * (dx, dy) = (a, b).\n    // This implies (dx, dy) = (a/c, b/c), where c is a common divisor of a and b.\n    // To satisfy the move constraints (dx <= k, dy <= k), we need a/c <= k and b/c <= k.\n    // To maximize our chances, we should make a/c and b/c as small as possible,\n    // which means choosing the largest possible c, i.e., c = gcd(a, b).\n    // If the condition holds for c = gcd(a,b), a cost-1 solution exists.\n    // Otherwise, it's impossible with one move.\n    \n    long long required_dx = a / g;\n    long long required_dy = b / g;\n\n    if (std::max(required_dx, required_dy) <= k) {\n        std::cout << 1 << std::endl;\n    } else {\n        // --- Cost 2 ---\n        // If a cost-1 solution is not possible, a cost-2 solution is always achievable.\n        // We can use two vectors:\n        // V1 = (gcd(a, k), 0) to cover the x-displacement.\n        // V2 = (0, gcd(b, k)) to cover the y-displacement.\n        // This construction always works and uses two distinct vectors.\n        std::cout << 2 << std::endl;\n    }\n}\n\nint main() {\n    // Fast I/O\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int t;\n    std::cin >> t;\n    while (t--) {\n        solve();\n    }\n\n    return 0;\n}\n```\"\"\"\n    ),\n  ],\n  role='model'\n) citation_metadata=None finish_message=None token_count=None finish_reason=<FinishReason.STOP: 'STOP'> url_context_metadata=None avg_logprobs=None grounding_metadata=None index=0 logprobs_result=None safety_ratings=None"
  ],
  "create_time": null,
  "model_version": "gemini-2.5-pro",
  "prompt_feedback": null,
  "response_id": "hA7ZaL2rM8Ok0-kPjLLnsAw",
  "usage_metadata": "cache_tokens_details=None cached_content_token_count=None candidates_token_count=1967 candidates_tokens_details=None prompt_token_count=313 prompt_tokens_details=[ModalityTokenCount(\n  modality=<MediaModality.TEXT: 'TEXT'>,\n  token_count=55\n), ModalityTokenCount(\n  modality=<MediaModality.IMAGE: 'IMAGE'>,\n  token_count=258\n)] thoughts_token_count=18931 tool_use_prompt_token_count=None tool_use_prompt_tokens_details=None total_token_count=21211 traffic_type=None",
  "automatic_function_calling_history": [],
  "parsed": null
}